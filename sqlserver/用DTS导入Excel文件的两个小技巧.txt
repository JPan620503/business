用DTS导入Excel文件的两个小技巧    minajo21（原作） 
  
关键字     DTS、Excel 
  


     我们在使用DTS向导，或是DTS对象做Excel文件导入SQL数据库时，很可能遇到一点小麻烦，下面以两个经常碰到的小问题来介绍一下处理的技巧。

     问题一

     在导入后，发现某些列中的一些内容被莫名其妙地置空了，明明Excel文件的这一行是有内容的，到了表里却变成了Null。怎么回事？

     原因是这样的，假设你的Excel文件中有如下的数据：

     1001    a1001    ab1001

     1002    a1002    ab1002

     1003    a1003    1000

     ...

     这时，1003这行的1003这一列就被置空了，原因是当这一列中有一个数据是字符串类型的数据，那么Excel就认为这一列的类型为字符串型，而当中在有int型的数据时，即Execl认为1000是int字符串型的数据。所以当导入到SQL中就把它默认为Null了。

    解决的直接办法是在Excel中将这些int型的数据转为char型的，即：

    1000 -> '1000

     但在实际当中，Excel的数据量会很大，总不可能一个一个的修改吧，其实简单且有效的方法是将此Excel文件另存为Text文件来导入。例如在VB的代码中可以这样实现：

     xlDestSheet.SaveAs App.Path & "\temp.txt", xlUnicodeText

     

     问题二

     在导入后，发现多出了很多全空的列。本来我的Excel文件只有5列，导入后发现多出了两列，且是全空的。Why?

     原因是这样，SQL在处理Excel的时，它会找所有行中列数最多的，然后以这个列的最大值做为目标表列的个数。在我们对Excel文件进行录入操作的时候，一不小心，可能会在本来没有列的地方多打了一个空格，或其它的字符，比如，我们的Excel文件应该只有A->D这四列，在我们在Excel文件中写数据的时候，可能不注意在E10这一列打了一个空格，这样就导致了象SQL导入时发生了上述的错误。在实际当中，这一现象也可能经常出现。

     解决的好办法，是先确定你要导入Excel文件的实际列数，然后将这些列复制到一个新的sheet当中，这样再导的时候，就可以避免这一问题了。

     例如在VB的代码中可以这样写：

     '加一个临时sheet
     Set xlDestSheet = xlApp.Worksheets.Add(after:=xlBook.Worksheets(1))
     xlDestSheet.name = "Temp"
     

     '假设Execl文件中有100行4列的数据
     xlWorksheet.Range("A1:D100").Copy Destination:=xlDestSheet.Range("A1")
     xlBook.Save

     在DTS的使用当中，还有很多小的技巧，让我们多总结，共同探讨吧

 
 
